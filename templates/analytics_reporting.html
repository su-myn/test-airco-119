{% extends "base.html" %}

{% block title %}Analytics & Reporting - PropertyHub{% endblock %}

{% block additional_styles %}
<style>
    .analytics-container {
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
        margin-bottom: 30px;
    }

    .analytics-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .analytics-title {
        font-size: 1.5rem;
        font-weight: bold;
        margin: 0;
    }

    .chart-container {
        height: 400px;
        margin-bottom: 30px;
        padding-bottom: 80px;
    }

    .filters-container {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
    }

    .filter-group {
        display: flex;
        flex-direction: column;
        min-width: 150px;
    }

    .filter-group label {
        margin-bottom: 5px;
        font-weight: bold;
    }

    .filter-group select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
    }

    .filter-actions {
        display: flex;
        gap: 10px;
        align-self: flex-end;
        margin-top: 23px;
    }

    .filter-btn {
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    .apply-btn {
        background-color: #ee4d2d;
        color: white;
    }

    .reset-btn {
        background-color: #6c757d;
        color: white;
    }

    .stats-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 30px;
    }

    .stat-card {
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 15px;
        min-width: 200px;
        flex: 1;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .stat-value {
        font-size: 2rem;
        font-weight: bold;
        color: #ee4d2d;
    }

    .stat-label {
        color: #6c757d;
        font-size: 0.9rem;
    }

    .chart-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        border-bottom: 1px solid #ddd;
    }

    .chart-tab {
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 3px solid transparent;
    }

    .chart-tab.active {
        border-bottom-color: #ee4d2d;
        font-weight: bold;
    }

    .tab-content {
        display: none;
    }

    .tab-content.active {
        display: block;
    }

    /* Responsive */
    @media (max-width: 768px) {
        .filters-container {
            flex-direction: column;
        }

        .filter-group {
            width: 100%;
        }

        .chart-tabs {
            flex-wrap: wrap;
        }

        .chart-container {
            height: 300px;
        }
    }

    /* Styles for Issue Solutions tab */
    .card-view .solution-card {
        transition: transform 0.2s, box-shadow 0.2s;
    }

    .card-view .solution-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    }

    .list-view table {
        border-collapse: collapse;
        width: 100%;
    }

    .list-view table th {
        position: sticky;
        top: 0;
        background-color: #f8f9fa;
        z-index: 10;
    }

    .list-view table tr:hover {
        background-color: #f8f9fa;
    }

    .issue-item.active {
        background-color: #f8f9fa !important;
        border-left-color: #ee4d2d !important;
        font-weight: bold !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="analytics-container">
    <div class="analytics-header">
        <h2 class="analytics-title">Analytics & Reporting</h2>
    </div>

    <div class="filters-container">
        <div class="filter-group">
            <label for="date-range">Date Range</label>
            <select id="date-range">
                <option value="all">All Time</option>
                <option value="hour">Last 1 Hour</option>
                <option value="today">Today</option>
                <option value="yesterday">Yesterday</option>
                <option value="this-week">This Week</option>
                <option value="last-week">Last Week</option>
                <option value="this-month">This Month</option>
                <option value="last-month">Last Month</option>
                <option value="this-year">This Year</option>
                <option value="last-year">Last Year</option>
            </select>
        </div>

        <div class="filter-group">
            <label for="category-filter">Category</label>
            <select id="category-filter">
                <option value="all">All Categories</option>
                {% for category in categories %}
                <option value="{{ category.id }}">{{ category.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-group">
            <label for="issue-item-filter">Issue</label>
            <select id="issue-item-filter">
                <option value="all">All Issues</option>
                <!-- Issue items will be populated dynamically based on category selection -->
            </select>
        </div>

        <div class="filter-group">
            <label for="priority-filter">Priority</label>
            <select id="priority-filter">
                <option value="all">All Priorities</option>
                {% for priority in priorities %}
                <option value="{{ priority.id }}">{{ priority.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-group">
            <label for="status-filter">Status</label>
            <select id="status-filter">
                <option value="all">All Statuses</option>
                {% for status in statuses %}
                {% if status.name not in ['In Progress', 'Rejected'] %}
                <option value="{{ status.id }}">{{ status.name }}</option>
                {% endif %}
                {% endfor %}
            </select>
        </div>

        <div class="filter-group">
            <label for="unit-filter">Unit</label>
            <select id="unit-filter">
                <option value="all">All Units</option>
                {% for unit in units %}
                <option value="{{ unit.unit_number }}">{{ unit.unit_number }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-group">
            <label for="reported-by-filter">Reported By</label>
            <select id="reported-by-filter">
                <option value="all">All Reporters</option>
                {% for reporter in reported_by_options %}
                <option value="{{ reporter.id }}">{{ reporter.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-group">
            <label for="type-filter">Type</label>
            <select id="type-filter">
                <option value="all">All Types</option>
                {% for type in types %}
                <option value="{{ type.id }}">{{ type.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="filter-actions">
            <button id="apply-filters" class="filter-btn apply-btn">Apply Filters</button>
            <button id="reset-filters" class="filter-btn reset-btn">Reset</button>
        </div>
    </div>

    <div class="stats-cards">
        <div class="stat-card">
            <div class="stat-value" id="total-issues">0</div>
            <div class="stat-label">Total Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="open-issues">0</div>
            <div class="stat-label">Pending Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="resolved-issues">0</div>
            <div class="stat-label">Resolved Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="total-cost">RM0.00</div>
            <div class="stat-label">Total Cost</div>
        </div>
    </div>

    <div class="chart-tabs">
        <div class="chart-tab active" data-tab="issues-by-status">Issues by Status, Priority & Reporter</div>
        <div class="chart-tab " data-tab="issues-over-time">Issues Over Time</div>
        <div class="chart-tab" data-tab="issues-by-category">Issues by Category</div>
        <div class="chart-tab" data-tab="issue-items">Issue Items</div>
        <div class="chart-tab" data-tab="cost-analysis">Cost Analysis</div>
        <div class="chart-tab" data-tab="issue-solutions">Issue Solutions</div>
        <div class="chart-tab" data-tab="unit-heatmap">Unit</div>
    </div>

    <div class="tab-content active" id="issues-by-status-content">
        <div style="display: flex; flex-wrap: wrap; gap: 20px;">
            <!-- Status Chart -->
            <div style="flex: 1; min-width: 300px;">
                <div class="chart-container" style="height: 350px;">
                    <canvas id="issues-by-status-chart"></canvas>
                </div>
            </div>

            <!-- Priority Chart -->
            <div style="flex: 1; min-width: 300px;">
                <div class="chart-container" style="height: 350px;">
                    <canvas id="status-tab-priority-chart"></canvas>
                </div>
            </div>

            <!-- Reported By Chart -->
            <div style="flex: 1; min-width: 300px;">
                <div class="chart-container" style="height: 350px;">
                    <canvas id="status-tab-reporter-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="tab-content" id="issues-over-time-content">
        <div class="chart-container">
            <canvas id="category-time-chart"></canvas>
        </div>

        <div style="margin-top: 20px; text-align: center;">
            <div id="category-toggle-buttons" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;">
                <!-- Toggle buttons will be added here dynamically -->
            </div>
        </div>

        <hr style="margin: 30px 0; border-color: #eee;">

        <!-- New Unit Comparison Chart -->

        <!-- Chart container now comes first -->
        <div class="chart-container">
            <canvas id="unit-comparison-chart"></canvas>
        </div>

        <!-- Toggle buttons now come after the chart -->
        <div style="margin-top: 20px; text-align: center;">
            <div id="unit-toggle-buttons" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 15px;">
                <!-- Unit toggle buttons will be added here dynamically -->
            </div>
            <button id="select-all-units" style="margin-right: 10px; padding: 5px 10px; background-color: #4169E1; color: white; border: none; border-radius: 4px; cursor: pointer;">Select All</button>
            <button id="clear-units" style="padding: 5px 10px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear All</button>
        </div>

    </div>

    <div class="tab-content" id="issues-by-category-content">
        <div style="display: flex; flex-wrap: wrap; gap: 20px;">
            <!-- Left side: Issues by Category chart -->
            <div style="flex: 1; min-width: 400px;">
                <div class="chart-container" style="height: 400px;">
                    <canvas id="issues-by-category-chart"></canvas>
                </div>
            </div>

            <!-- Right side: Top Issue Types chart -->
            <div style="flex: 1; min-width: 400px;">
                <div class="chart-container" style="height: 400px;">
                    <canvas id="issue-types-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="tab-content" id="issue-items-content">
        <div style="display: flex; flex-wrap: wrap; gap: 20px;">
            <!-- Left side: Pie Chart with standard legend -->
            <div style="flex: 3; min-width: 500px;">
                <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Issue Items Distribution</h4>
                <div style="position: relative; height: 600px;">
                    <canvas id="issue-items-pie-chart"></canvas>
                </div>
            </div>

            <!-- Right side: Horizontal Bar Chart - make smaller -->
            <div style="flex: 2; min-width: 300px; max-width: 450px;">
                <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Top Issue Items</h4>
                <div style="height: 600px;">

                    <canvas id="issue-items-bar-chart"></canvas>
                </div>
            </div>
        </div>
    </div>



    <div class="tab-content" id="cost-analysis-content">
        <div style="display: flex; flex-wrap: wrap; gap: 20px;">
            <!-- Left side: Cost Analysis by Category chart -->
            <div style="flex: 1; min-width: 400px;">
                <div class="chart-container" style="height: 400px;">
                    <canvas id="cost-analysis-chart"></canvas>
                </div>
            </div>

            <!-- Right side: Top Units by Cost chart -->
            <div style="flex: 1; min-width: 400px;">
                <div class="chart-container" style="height: 400px;">
                    <canvas id="units-by-cost-chart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="tab-content" id="issue-solutions-content">
        <div style="display: flex; gap: 20px; height: 600px;">
            <!-- Left Panel: Hierarchical Categories and Items -->
            <div style="flex: 1; overflow-y: auto; min-width: 300px; border-right: 1px solid #eee; padding-right: 20px;">
                <h4 style="margin-top: 10px; margin-bottom: 15px; font-weight: 500; color: #333;">Issue Categories</h4>
                <div id="category-tree"></div>
            </div>

            <!-- Right Panel: Solutions Display -->
            <div style="flex: 2; overflow-y: auto; padding-left: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h4 style="margin-top: 10px; margin-bottom: 0; font-weight: 500; color: #333;">Solutions</h4>
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <!-- Unit Filter -->
                        <div>
                            <select id="solution-unit-filter" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="all">All Units</option>
                                <!-- This will be populated dynamically -->
                            </select>
                        </div>

                        <!-- Reported By Filter -->
                        <div>
                            <select id="solution-reporter-filter" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="all">All Reporters</option>
                                <!-- This will be populated dynamically -->
                            </select>
                        </div>

                        <!-- Date Filter (existing) -->
                        <div>
                            <select id="solution-date-filter" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="all">All Time</option>
                                <option value="today">Today</option>
                                <option value="yesterday">Yesterday</option>
                                <option value="this-week">This Week</option>
                                <option value="last-week">Last Week</option>
                                <option value="this-month">This Month</option>
                                <option value="last-month">Last Month</option>
                                <option value="this-year">This Year</option>
                                <option value="last-year">Last Year</option>
                            </select>
                        </div>

                        <!-- View Toggle (existing) -->
                        <div style="display: flex; border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                            <button id="card-view-btn" class="view-toggle-btn active" style="padding: 5px 10px; background: #ee4d2d; color: white; border: none; cursor: pointer;">Card View</button>
                            <button id="list-view-btn" class="view-toggle-btn" style="padding: 5px 10px; background: #f8f9fa; color: #333; border: none; cursor: pointer;">List View</button>
                        </div>
                    </div>
                </div>

                <div id="solution-container" class="card-view">
                    <div id="no-solution-selected" style="text-align: center; padding: 50px; color: #6c757d;">
                        <p style="font-size: 18px;">Select an issue item to view solutions</p>
                    </div>
                    <div id="solutions-list" style="display: none;"></div>
                </div>
            </div>

        </div>
    </div>

    <div class="tab-content" id="unit-heatmap-content">
        <div class="chart-container" style="height: 600px; position: relative; margin-top: 0px;">
            <div id="unit-heatmap-chart"></div>
        </div>
    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    // Global chart instances (for destroying and recreating)
    let timeChart, todayChart, categoryChart, priorityChart, statusChart, costChart, issueTypesChart, unitHeatmapChart;
    // Demo data - will be replaced by API data
    let issuesData = [];

    // DOM ready
    document.addEventListener('DOMContentLoaded', function() {
        // Fetch issues data from API
        fetchIssuesData();

        // Tab switching
        document.querySelectorAll('.chart-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.chart-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                this.classList.add('active');

                const tabId = this.getAttribute('data-tab');
                document.getElementById(`${tabId}-content`).classList.add('active');
            });
        });

        // Filter events
        document.getElementById('apply-filters').addEventListener('click', applyFilters);
        document.getElementById('reset-filters').addEventListener('click', resetFilters);
    });

    // Add this event listener to update issue items when category changes
    document.getElementById('category-filter').addEventListener('change', function() {
        updateIssueItemsDropdown(this.value);
    });

    // Function to update issue items dropdown based on selected category
    function updateIssueItemsDropdown(categoryId) {
        const issueItemFilter = document.getElementById('issue-item-filter');

        // Clear current options except the first one
        while (issueItemFilter.options.length > 1) {
            issueItemFilter.remove(1);
        }

        // If no category is selected, return
        if (categoryId === 'all') return;

        // Fetch issue items for the selected category
        fetch(`/api/get_issue_items/${categoryId}`)
            .then(response => response.json())
            .then(items => {
                // Add each item to the dropdown
                items.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;
                    option.textContent = item.name;
                    issueItemFilter.appendChild(option);
                });
            })
            .catch(error => {
                console.error('Error fetching issue items:', error);
            });
    }

    function fetchIssuesData() {
        // Get issues data from API
        fetch('/api/analytics/issues')
            .then(response => response.json())
            .then(data => {
                issuesData = data;
                updateDashboard(issuesData);
            })
            .catch(error => console.error('Error fetching issues data:', error));
    }


    function applyFilters() {
        const dateRange = document.getElementById('date-range').value;
        const categoryId = document.getElementById('category-filter').value;
        const issueItemId = document.getElementById('issue-item-filter').value;
        const priorityId = document.getElementById('priority-filter').value;
        const statusId = document.getElementById('status-filter').value;
        const unitFilter = document.getElementById('unit-filter').value;
        const reportedById = document.getElementById('reported-by-filter').value;
        const typeId = document.getElementById('type-filter').value;

        // Build query parameters
        let params = new URLSearchParams();

        // Handle different date ranges with updated logic
        if (dateRange !== 'all') {
            switch (dateRange) {
                case 'hour':
                    params.append('time_filter', 'hour');
                    break;
                case 'today':
                    params.append('time_filter', 'today');
                    break;
                case 'yesterday':
                    params.append('time_filter', 'yesterday');
                    break;
                case 'this-week':
                    params.append('time_filter', 'this-week');
                    break;
                case 'last-week':
                    params.append('time_filter', 'last-week');
                    break;
                case 'this-month':
                    params.append('time_filter', 'this-month');
                    break;
                case 'last-month':
                    params.append('time_filter', 'last-month');
                    break;
                case 'this-year':
                    params.append('time_filter', 'this-year');
                    break;
                case 'last-year':
                    params.append('time_filter', 'last-year');
                    break;
            }
        }

        if (categoryId !== 'all') params.append('category_id', categoryId);
        if (issueItemId !== 'all') params.append('issue_item_id', issueItemId);
        if (priorityId !== 'all') params.append('priority_id', priorityId);
        if (statusId !== 'all') params.append('status_id', statusId);
        if (unitFilter !== 'all') params.append('unit', unitFilter);
        if (reportedById !== 'all') params.append('reported_by_id', reportedById);
        if (typeId !== 'all') params.append('type_id', typeId);

        // Fetch filtered data
        fetch('/api/analytics/issues?' + params.toString())
            .then(response => response.json())
            .then(data => {
                issuesData = data;
                updateDashboard(issuesData);
            })
            .catch(error => console.error('Error fetching filtered issues data:', error));
    }

    function resetFilters() {
        document.getElementById('date-range').value = 'all';
        document.getElementById('category-filter').value = 'all';
        document.getElementById('issue-item-filter').value = 'all';
        document.getElementById('priority-filter').value = 'all';
        document.getElementById('status-filter').value = 'all';
        document.getElementById('unit-filter').value = 'all';
        document.getElementById('reported-by-filter').value = 'all';
        document.getElementById('type-filter').value = 'all';

        fetchIssuesData();
    }


    function updateDashboard(data) {
        updateStatCards(data);
        createCategoryTimeChart(data);
        createUnitComparisonChart(data);
        createCategoryChart(data);
        createIssueItemsCharts(data);
        createIssueTypesChart(data);
        createStatusChart(data);
        createCostChart(data);
        createUnitsByCostChart(data);
        createUnitHeatmap(data);
    }

    function updateStatCards(data) {
        // Update stat cards with calculated values
        document.getElementById('total-issues').textContent = data.length;

        const openIssues = data.filter(issue =>
            issue.status_name === 'Pending' ||
            issue.status_name === 'In Progress'
        ).length;
        document.getElementById('open-issues').textContent = openIssues;

        const resolvedIssues = data.filter(issue =>
            issue.status_name === 'Resolved'
        ).length;
        document.getElementById('resolved-issues').textContent = resolvedIssues;

        // Calculate total cost, filtering out null/undefined values
        const validCosts = data.filter(issue => issue.cost !== null && issue.cost !== undefined);
        let totalCost = 0;
        if (validCosts.length > 0) {
            totalCost = validCosts.reduce((sum, issue) => sum + Number(issue.cost), 0);
        }
        document.getElementById('total-cost').textContent = 'RM' + totalCost.toFixed(2);
    }


    function createCategoryChart(data) {
        const ctx = document.getElementById('issues-by-category-chart').getContext('2d');

        // Destroy previous chart if exists
        if (categoryChart) categoryChart.destroy();

        // Group issues by category
        const issuesByCategory = {};
        data.forEach(issue => {
            if (issue.category_name) {
                if (!issuesByCategory[issue.category_name]) {
                    issuesByCategory[issue.category_name] = 0;
                }
                issuesByCategory[issue.category_name] += 1;
            }
        });

        // Prepare data for chart
        const categories = Object.keys(issuesByCategory);
        const categoryData = categories.map(cat => issuesByCategory[cat]);

        // Use the specific color scheme for this chart
        const categoryColors = [
            'rgba(129, 130, 200, 0.7)', // Purple (#8182c8)
            'rgba(243, 199, 113, 0.7)', // Gold (#f3c771)
            'rgba(129, 166, 227, 0.7)', // Light Blue (#81a6e3)
            'rgba(146, 208, 181, 0.7)', // Mint Green (#92d0b5)
            'rgba(182, 224, 127, 0.7)', // Light Green (#b6e07f)
            'rgba(232, 234, 119, 0.7)', // Yellow (#e8ea77)
            'rgba(239, 147, 103, 0.7)', // Orange (#ef9367)
            'rgba(243, 122, 119, 0.7)', // Coral (#f37a77)
            'rgba(108, 110, 163, 0.7)', // Deep Purple (#6c6ea3)
            'rgba(44, 71, 97, 0.7)'     // Navy (#2c4761)
        ];

        // Make sure we have enough colors by repeating if necessary
        const backgroundColors = [];
        for (let i = 0; i < categories.length; i++) {
            backgroundColors.push(categoryColors[i % categoryColors.length]);
        }

        // Create horizontal bar chart
        categoryChart = new Chart(ctx, {
            type: 'bar', // Still use 'bar' type
            data: {
                labels: categories,
                datasets: [{
                    label: 'Number of Issues',
                    data: categoryData,
                    backgroundColor: backgroundColors,
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y', // This makes the bars horizontal
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issues by Category',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        display: false
                    }
                },
                scales: {
                    x: { // This was 'y' in vertical chart
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Issues'
                        }
                    }
                }
            }
        });
    }

    function createIssueTypesChart(data) {
        const ctx = document.getElementById('issue-types-chart').getContext('2d');

        // Destroy previous chart if exists
        if (issueTypesChart) issueTypesChart.destroy();

        // Group issues by issue_item_name
        const issuesByType = {};
        data.forEach(issue => {
            if (issue.issue_item_name) {
                if (!issuesByType[issue.issue_item_name]) {
                    issuesByType[issue.issue_item_name] = 0;
                }
                issuesByType[issue.issue_item_name] += 1;
            }
        });

        // Sort issue types by count and take top 10
        const sortedTypes = Object.entries(issuesByType)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

        const issueTypes = sortedTypes.map(item => item[0]);
        const typeCounts = sortedTypes.map(item => item[1]);

        // Use the same color scheme as the category chart
        const typeColors = [
            'rgba(129, 130, 200, 0.7)', // Purple (#8182c8)
            'rgba(243, 199, 113, 0.7)', // Gold (#f3c771)
            'rgba(129, 166, 227, 0.7)', // Light Blue (#81a6e3)
            'rgba(146, 208, 181, 0.7)', // Mint Green (#92d0b5)
            'rgba(182, 224, 127, 0.7)', // Light Green (#b6e07f)
            'rgba(232, 234, 119, 0.7)', // Yellow (#e8ea77)
            'rgba(239, 147, 103, 0.7)', // Orange (#ef9367)
            'rgba(243, 122, 119, 0.7)', // Coral (#f37a77)
            'rgba(108, 110, 163, 0.7)', // Deep Purple (#6c6ea3)
            'rgba(44, 71, 97, 0.7)'     // Navy (#2c4761)
        ];

        // Create donut chart
        issueTypesChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: issueTypes,
                datasets: [{
                    data: typeCounts,
                    backgroundColor: typeColors.slice(0, issueTypes.length),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Top 10 Issue Types',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        position: 'right',
                        labels: {
                            boxWidth: 12,
                            font: {
                                size: 11
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                },
                cutout: '50%'
            }
        });
    }



    // Global variables for new charts
    let statusTabPriorityChart = null;
    let statusTabReporterChart = null;

    // Enhanced version of createStatusChart function that also creates the other charts
    function createStatusChart(data) {
        const ctx = document.getElementById('issues-by-status-chart').getContext('2d');

        // Destroy previous chart if exists
        if (statusChart) statusChart.destroy();

        // Group issues by status
        const issuesByStatus = {};
        data.forEach(issue => {
            if (issue.status_name) {
                if (!issuesByStatus[issue.status_name]) {
                    issuesByStatus[issue.status_name] = 0;
                }
                issuesByStatus[issue.status_name] += 1;
            }
        });

        // Predefined colors for statuses
        const statusColors = {
            'Pending': '#ffc107',      // Warning/Yellow
            'In Progress': '#17a2b8',  // Info/Blue
            'Resolved': '#28a745',     // Success/Green
            'Rejected': '#dc3545'      // Danger/Red
        };

        // Prepare data for chart
        const statuses = Object.keys(issuesByStatus);
        const statusData = statuses.map(status => issuesByStatus[status]);
        const colors = statuses.map(status => statusColors[status] || '#6c757d'); // Default gray

        // Create chart
        statusChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: statuses,
                datasets: [{
                    data: statusData,
                    backgroundColor: colors
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issues by Status',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });

        // Create the other charts
        createStatusTabPriorityChart(data);
        createStatusTabReporterChart(data);
    }

    // Function to create Issues by Priority donut chart
    function createStatusTabPriorityChart(data) {
        const ctx = document.getElementById('status-tab-priority-chart').getContext('2d');

        // Destroy previous chart if exists
        if (statusTabPriorityChart) statusTabPriorityChart.destroy();

        // Group issues by priority
        const issuesByPriority = {};
        data.forEach(issue => {
            if (issue.priority_name) {
                if (!issuesByPriority[issue.priority_name]) {
                    issuesByPriority[issue.priority_name] = 0;
                }
                issuesByPriority[issue.priority_name] += 1;
            } else {
                // Count issues with undefined priority
                if (!issuesByPriority['Unspecified']) {
                    issuesByPriority['Unspecified'] = 0;
                }
                issuesByPriority['Unspecified'] += 1;
            }
        });

        // Color scheme for priorities (Red, Yellow, Green as requested)
        const priorityColors = {
            'High': '#dc3545',    // Red
            'Medium': '#ffc107',  // Yellow
            'Low': '#28a745',     // Green
            'Unspecified': '#6c757d' // Gray
        };

        // Prepare data for chart
        const priorities = Object.keys(issuesByPriority);
        const priorityData = priorities.map(priority => issuesByPriority[priority]);
        const colors = priorities.map(priority => priorityColors[priority] || '#6c757d');

        // Create chart
        statusTabPriorityChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: priorities,
                datasets: [{
                    data: priorityData,
                    backgroundColor: colors
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issues by Priority',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Function to create Issues by Reporter donut chart
    function createStatusTabReporterChart(data) {
        const ctx = document.getElementById('status-tab-reporter-chart').getContext('2d');

        // Destroy previous chart if exists
        if (statusTabReporterChart) statusTabReporterChart.destroy();

        // Group issues by reporter
        const issuesByReporter = {};
        data.forEach(issue => {
            if (issue.reported_by_name) {
                if (!issuesByReporter[issue.reported_by_name]) {
                    issuesByReporter[issue.reported_by_name] = 0;
                }
                issuesByReporter[issue.reported_by_name] += 1;
            } else {
                // Count issues with undefined reporter
                if (!issuesByReporter['Unspecified']) {
                    issuesByReporter['Unspecified'] = 0;
                }
                issuesByReporter['Unspecified'] += 1;
            }
        });

        // Color scheme for reporters
        const reporterColors = [
            '#4285F4', // Blue
            '#EA4335', // Red
            '#FBBC05', // Yellow
            '#34A853', // Green
            '#FF9800', // Orange
            '#9C27B0', // Purple
            '#00BCD4', // Cyan
            '#795548', // Brown
            '#607D8B', // Gray
            '#6c757d'  // Darker Gray for unspecified
        ];

        // Prepare data for chart
        const reporters = Object.keys(issuesByReporter);
        const reporterData = reporters.map(reporter => issuesByReporter[reporter]);
        const colors = reporters.map((_, index) => reporterColors[index % reporterColors.length]);

        // Create chart
        statusTabReporterChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: reporters,
                datasets: [{
                    data: reporterData,
                    backgroundColor: colors
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issues by Reporter',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    function createCostChart(data) {
            const ctx = document.getElementById('cost-analysis-chart').getContext('2d');

            // Destroy previous chart if exists
            if (costChart) costChart.destroy();

            // Filter out issues without cost data
            const issuesWithCost = data.filter(issue =>
                issue.cost !== null &&
                issue.cost !== undefined &&
                issue.category_name
            );

            // Group costs by category
            const costByCategory = {};

            issuesWithCost.forEach(issue => {
                if (!costByCategory[issue.category_name]) {
                    costByCategory[issue.category_name] = 0;
                }

                costByCategory[issue.category_name] += Number(issue.cost);
            });

            // Prepare data for chart
            const categories = Object.keys(costByCategory);
            const totalCostData = categories.map(cat => costByCategory[cat]);

            // Create chart
            costChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: categories,
                    datasets: [
                        {
                            label: 'Total Cost(RM)',
                            data: totalCostData,
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Cost Analysis by Category',
                            font: {
                                size: 16
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Total Cost (RM)'
                            }
                        }
                    }
                }
            });
        }


    // Helper function to generate colors
    function generateColors(count) {
        const baseColors = [
            'rgba(255, 99, 132, 0.7)',
            'rgba(54, 162, 235, 0.7)',
            'rgba(255, 206, 86, 0.7)',
            'rgba(75, 192, 192, 0.7)',
            'rgba(153, 102, 255, 0.7)',
            'rgba(255, 159, 64, 0.7)',
            'rgba(199, 199, 199, 0.7)',
            'rgba(83, 102, 255, 0.7)',
            'rgba(40, 159, 169, 0.7)',
            'rgba(210, 111, 140, 0.7)'
        ];

        let colors = [];
        for (let i = 0; i < count; i++) {
            colors.push(baseColors[i % baseColors.length]);
        }

        return colors;
    }


    function createUnitsByCostChart(data) {
        const ctx = document.getElementById('units-by-cost-chart').getContext('2d');

        // Destroy previous chart if exists
        if (window.unitsByCostChart) window.unitsByCostChart.destroy();

        // Filter out issues without cost data
        const issuesWithCost = data.filter(issue =>
            issue.cost !== null &&
            issue.cost !== undefined &&
            issue.unit
        );

        // Group costs by unit
        const costByUnit = {};

        issuesWithCost.forEach(issue => {
            if (!costByUnit[issue.unit]) {
                costByUnit[issue.unit] = 0;
            }

            costByUnit[issue.unit] += Number(issue.cost);
        });

        // Sort units by cost and take top 10
        const sortedUnits = Object.entries(costByUnit)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);

        const units = sortedUnits.map(item => item[0]);
        const costs = sortedUnits.map(item => item[1]);

        // Create horizontal bar chart
        window.unitsByCostChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: units,
                datasets: [{
                    label: 'Total Cost (RM)',
                    data: costs,
                    backgroundColor: 'rgba(54, 162, 235, 0.5)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y',  // This makes the chart horizontal
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Top Units by Total Cost',
                        font: {
                            size: 16
                        }
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Total Cost: RM${context.raw.toFixed(2)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Total Cost (RM)'
                        }
                    }
                }
            }
        });
    }
</script>
<script>
    // Function to create the unit heatmap with D3.js
    function createUnitHeatmap(data) {
        // Clear any existing chart
        d3.select("#unit-heatmap-chart").selectAll("*").remove();

        // Extract unique units and categories
        const uniqueUnits = [...new Set(data.map(issue => issue.unit))].filter(Boolean);
        const uniqueCategories = ["Building Issue", "Cleaning Issue", "Plumbing Issues",
                                 "Electrical Issue", "Furniture Issue", "Check-in Issue", "Aircond Issue"];

        // Sort units alphabetically
        uniqueUnits.sort();

        // Create a mapping of issue counts by unit and category
        const issueCountsByUnitAndCategory = {};

        // Initialize with zero values for all units and categories
        uniqueUnits.forEach(unit => {
            issueCountsByUnitAndCategory[unit] = {};
            uniqueCategories.forEach(category => {
                issueCountsByUnitAndCategory[unit][category] = 0;
            });
        });

        // Count issues by unit and category
        data.forEach(issue => {
            if (issue.unit && issue.category_name && uniqueUnits.includes(issue.unit)) {
                issueCountsByUnitAndCategory[issue.unit][issue.category_name]++;
            }
        });

        // Determine cell height based on number of rows
        let cellHeight;
        if (uniqueUnits.length <= 10) {
            cellHeight = 50; // Taller cells for fewer rows
        } else if (uniqueUnits.length <= 20) {
            cellHeight = 40; // Medium height for medium number of rows
        } else if (uniqueUnits.length <= 30) {
            cellHeight = 30; // Smaller height for more rows
        } else {
            cellHeight = 25; // Smallest height for many rows
        }

        // Set up dimensions with explicit spacing for title and legend
        const margin = {top: 80, right: 25, bottom: 140, left: 120}; // Increased bottom margin
        const cellWidth = 80; // Width of each cell

        // Calculate space needed for the main heatmap
        const heatmapWidth = uniqueCategories.length * cellWidth;
        const heatmapHeight = uniqueUnits.length * cellHeight;

        // Calculate total height and width needed
        const totalWidth = Math.max(800, heatmapWidth + margin.left + margin.right);
        const totalHeight = heatmapHeight + margin.top + margin.bottom; // Includes space for title and legend

        // Create a container div with fixed height and scrollable content
        const containerDiv = d3.select("#unit-heatmap-chart")
            .style("position", "relative")
            .style("overflow-x", "auto")
            .style("overflow-y", "auto")
            .style("width", "100%")
            .style("height", "600px") // Fixed height container
            .style("background-color", "white") // Ensure white background
            .style("display", "flex")        // Add flex display
            .style("justify-content", "center") // Center horizontally
            .style("align-items", "flex-start"); // Align to top vertically

        // Create SVG element with total dimensions
        const svg = containerDiv.append("svg")
            .attr("width", totalWidth)
            .attr("height", totalHeight)
            .style("display", "block") // Make sure SVG is block-level
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Add title - positioned relative to the svg, not the heatmap
        svg.append("text")
            .attr("x", heatmapWidth / 2) // Center relative to the heatmap width
            .attr("y", -60) // Fixed distance above the heatmap
            .attr("text-anchor", "middle")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .text("Issues by Unit and Category");

        // Create scales
        const x = d3.scaleBand()
            .range([0, heatmapWidth])
            .domain(uniqueCategories)
            .padding(0.05);

        const y = d3.scaleBand()
            .range([0, heatmapHeight])
            .domain(uniqueUnits)
            .padding(0.05);

        // Calculate max value for color scale
        const maxValue = Math.max(1, ...Object.values(issueCountsByUnitAndCategory)
            .flatMap(categoryMap => Object.values(categoryMap)));

        // Define color scale based on the 5 colors specified
        const colorScale = d3.scaleThreshold()
            .domain([1, Math.ceil(maxValue/5), Math.ceil(2*maxValue/5), Math.ceil(3*maxValue/5), Math.ceil(4*maxValue/5), maxValue])
            .range([
                "#527e0d", // forest green for 0 value (changed from white) - 0%
                "#527e0d", // forest green (least issues) - 0% up to 20%
                "#849d2b", // olive green  - 20% to 40%
                "#edb161", // tan/gold (moderate) - 40% up to 60%
                "#9c6342", // brown red - 60% up to 80%
                "#ec272b",  // bright red (most issues) - 80% up to 100%
                "#ec272b"  // bright red (most issues) - 100%
            ]);

        // Add Y axis
        svg.append("g")
            .style("font-size", "12px")
            .call(d3.axisLeft(y).tickSize(0))
            .select(".domain").remove();

        // Create multi-line category labels (2 rows) at the bottom
        uniqueCategories.forEach((category, i) => {
            // Split labels into two lines if needed
            let line1, line2;
            if (category.includes(" ")) {
                const parts = category.split(" ");
                const midpoint = Math.floor(parts.length / 2);
                line1 = parts.slice(0, midpoint).join(" ");
                line2 = parts.slice(midpoint).join(" ");
            } else {
                line1 = category;
                line2 = "";
            }

            // First line of text at bottom
            svg.append("text")
                .attr("x", x(category) + x.bandwidth() / 2)
                .attr("y", heatmapHeight + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .text(line1);

            // Second line of text at bottom (if exists)
            if (line2) {
                svg.append("text")
                    .attr("x", x(category) + x.bandwidth() / 2)
                    .attr("y", heatmapHeight + 40)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text(line2);
            }
        });

        // Create multi-line category labels (2 rows) at the top
        uniqueCategories.forEach((category, i) => {
            // Split labels into two lines if needed
            let line1, line2;
            if (category.includes(" ")) {
                const parts = category.split(" ");
                const midpoint = Math.floor(parts.length / 2);
                line1 = parts.slice(0, midpoint).join(" ");
                line2 = parts.slice(midpoint).join(" ");
            } else {
                line1 = category;
                line2 = "";
            }

            // First line of text at top
            svg.append("text")
                .attr("x", x(category) + x.bandwidth() / 2)
                .attr("y", -40)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .text(line1);

            // Second line of text at top (if exists)
            if (line2) {
                svg.append("text")
                    .attr("x", x(category) + x.bandwidth() / 2)
                    .attr("y", -20)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text(line2);
            }
        });

        // Create the heatmap cells
        svg.selectAll()
            .data(uniqueUnits.flatMap(unit => {
                return uniqueCategories.map(category => {
                    return {
                        unit: unit,
                        category: category,
                        value: issueCountsByUnitAndCategory[unit][category]
                    };
                });
            }))
            .enter()
            .append("rect")
                .attr("x", d => x(d.category))
                .attr("y", d => y(d.unit))
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", d => colorScale(d.value))
                .style("stroke", "white")
                .style("stroke-width", 1)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .style("stroke", "#333")
                        .style("stroke-width", 2);

                    // Show tooltip
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(`<strong>Unit:</strong> ${d.unit}<br><strong>Category:</strong> ${d.category}<br><strong>Issues:</strong> ${d.value}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .style("stroke", "white")
                        .style("stroke-width", 1);

                    // Hide tooltip
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

        // Add the values in each cell
        svg.selectAll()
            .data(uniqueUnits.flatMap(unit => {
                return uniqueCategories.map(category => {
                    return {
                        unit: unit,
                        category: category,
                        value: issueCountsByUnitAndCategory[unit][category]
                    };
                });
            }))
            .enter()
            .append("text")
                .attr("x", d => x(d.category) + x.bandwidth() / 2)
                .attr("y", d => y(d.unit) + y.bandwidth() / 2)
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "middle")
                .style("font-size", "12px")
                .style("fill", d => d.value > maxValue * 0.6 ? "white" : "black")
                .text(d => d.value);

        // Create tooltip
        const tooltip = d3.select("body").append("div")
            .attr("class", "d3-tooltip")
            .style("opacity", 0)
            .style("position", "absolute")
            .style("background-color", "white")
            .style("border", "1px solid #ddd")
            .style("border-radius", "4px")
            .style("padding", "10px")
            .style("pointer-events", "none")
            .style("z-index", 1000);

        // Create legend - position it clearly below the heatmap
        const legendWidth = 300;
        const legendHeight = 60;

        // Create separate group for legend with proper positioning
        const legend = svg.append("g")
            .attr("transform", `translate(${(heatmapWidth - legendWidth) / 2}, ${heatmapHeight + 70})`);

        const legendColors = ["#527e0d", "#849d2b", "#edb161", "#9c6342", "#ec272b"];
        const legendLabels = ["Least", "Less", "Moderate", "Much", "Greatest"];

        // Create legend rectangles and labels
        legendColors.forEach((color, i) => {
            legend.append("rect")
                .attr("x", i * (legendWidth / legendColors.length))
                .attr("width", legendWidth / legendColors.length)
                .attr("height", 20)
                .style("fill", color);

            legend.append("text")
                .attr("x", (i * (legendWidth / legendColors.length)) + (legendWidth / legendColors.length / 2))
                .attr("y", 35)
                .attr("text-anchor", "middle")
                .style("font-size", "10px")
                .text(legendLabels[i]);
        });

        legend.append("text")
            .attr("x", legendWidth / 2)
            .attr("y", -5)
            .attr("text-anchor", "middle")
            .style("font-size", "12px")
            .text("Number of Issues");
    }
</script>
<script>
    // Issues Over Time Tab
    // Global variable to track category chart
    let categoryTimeChart = null;

    // Function to get date range for last 12 months
    function getLast12Months() {
        const months = [];
        const labels = [];
        const today = new Date();

        // Array of month abbreviations
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        for (let i = 11; i >= 0; i--) {
            const d = new Date();
            d.setMonth(today.getMonth() - i);

            const monthYear = `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}`;
            // Use month name abbreviation instead of number
            const monthLabel = `${monthNames[d.getMonth()]}${d.getFullYear().toString().slice(2)}`;

            months.push(monthYear);
            labels.push(monthLabel);
        }

        return { months, labels };
    }

    // Create the interactive category time chart
    function createCategoryTimeChart(data) {
        const ctx = document.getElementById('category-time-chart').getContext('2d');

        // Destroy previous chart if exists
        if (categoryTimeChart) categoryTimeChart.destroy();

        // Get the date range for last 12 months
        const { months, labels } = getLast12Months();

        // Category list (matching the categories from your data)
        const categories = [
            "Building Issue",
            "Cleaning Issue",
            "Plumbing Issues",
            "Electrical Issue",
            "Furniture Issue",
            "Check-in Issue",
            "Aircond Issue"
        ];

        // Color scheme for categories
        const categoryColors = {
            "Building Issue": "#8182c8", // Purple
            "Cleaning Issue": "#f3c771", // Gold
            "Plumbing Issues": "#81a6e3", // Light Blue
            "Electrical Issue": "#92d0b5", // Mint Green
            "Furniture Issue": "#b6e07f", // Light Green
            "Check-in Issue": "#e8ea77", // Yellow
            "Aircond Issue": "#ef9367"  // Orange
        };

        // Process data to count issues by category and month
        const issuesByCategory = {};

        // Initialize structure for all categories and months
        categories.forEach(category => {
            issuesByCategory[category] = {};
            months.forEach(month => {
                issuesByCategory[category][month] = 0;
            });
        });

        // Count issues
        data.forEach(issue => {
            if (issue.category_name && categories.includes(issue.category_name)) {
                const date = new Date(issue.date_added);
                const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;

                // Only count if it's within our 12-month window
                if (months.includes(monthYear)) {
                    issuesByCategory[issue.category_name][monthYear]++;
                }
            }
        });

        // Prepare datasets for the chart
        const datasets = categories.map(category => {
            return {
                label: category,
                data: months.map(month => issuesByCategory[category][month]),
                borderColor: categoryColors[category],
                backgroundColor: categoryColors[category] + '20', // Adding transparency
                borderWidth: 2,
                pointRadius: 3,
                pointHoverRadius: 5,
                tension: 0.1,
                fill: false,
                hidden: false // All categories visible by default
            };
        });

        // Create chart
        categoryTimeChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issues Comparison by Category',
                        font: {
                            size: 16,
                            weight: 'bold'
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    },
                    legend: {
                        display: false // Hide default legend since we're using custom toggle buttons
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Month'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Issues'
                        },
                        suggestedMin: 0,
                        ticks: {
                            stepSize: 1
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });

        // Create toggle buttons for each category
        createCategoryToggleButtons(categories, categoryColors);
    }

    // Create toggle buttons for the categories
    function createCategoryToggleButtons(categories, colors) {
        const container = document.getElementById('category-toggle-buttons');
        container.innerHTML = ''; // Clear existing buttons

        categories.forEach(category => {
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'inline-block';
            buttonContainer.style.margin = '5px';

            const button = document.createElement('button');
            button.innerText = category;
            button.style.background = colors[category];
            button.style.color = 'white';
            button.style.border = 'none';
            button.style.padding = '8px 15px';
            button.style.borderRadius = '20px';
            button.style.cursor = 'pointer';
            button.style.opacity = '1';
            button.style.transition = 'opacity 0.3s';
            button.dataset.active = 'true';
            button.dataset.category = category;

            button.addEventListener('click', function() {
                const isActive = this.dataset.active === 'true';

                // Toggle active state
                this.dataset.active = isActive ? 'false' : 'true';
                this.style.opacity = isActive ? '0.5' : '1';

                // Find the dataset in the chart
                const datasetIndex = categoryTimeChart.data.datasets.findIndex(d => d.label === this.dataset.category);

                if (datasetIndex !== -1) {
                    // Toggle visibility
                    categoryTimeChart.data.datasets[datasetIndex].hidden = isActive;
                    categoryTimeChart.update();
                }
            });

            buttonContainer.appendChild(button);
            container.appendChild(buttonContainer);
        });
    }

    // Global variable for unit comparison chart
    let unitComparisonChart = null;

    // Color pool for units
    const unitColorPool = [
        '#4285F4', '#EA4335', '#FBBC05', '#34A853', // Google colors
        '#3498db', '#e74c3c', '#2ecc71', '#f39c12', // Flat UI colors
        '#9b59b6', '#1abc9c', '#d35400', '#c0392b',
        '#16a085', '#8e44ad', '#2980b9', '#f1c40f',
        '#27ae60', '#e67e22', '#7f8c8d', '#2c3e50'  // Additional colors
    ];

    // Function to create the unit comparison chart
    function createUnitComparisonChart(data) {
        const ctx = document.getElementById('unit-comparison-chart').getContext('2d');

        // Destroy previous chart if exists
        if (unitComparisonChart) unitComparisonChart.destroy();

        // Get the date range for last 12 months (reuse function from previous chart)
        const { months, labels } = getLast12Months();

        // Get all unique units from the data
        const units = [...new Set(data.map(issue => issue.unit))].filter(Boolean);

        // Process data to count issues by unit and month
        const issuesByUnit = {};

        // Initialize structure for all units and months
        units.forEach((unit, index) => {
            issuesByUnit[unit] = {
                color: unitColorPool[index % unitColorPool.length], // Assign color from pool
                data: {}
            };

            months.forEach(month => {
                issuesByUnit[unit].data[month] = 0;
            });
        });

        // Count issues
        data.forEach(issue => {
            if (issue.unit && units.includes(issue.unit)) {
                const date = new Date(issue.date_added);
                const monthYear = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;

                // Only count if it's within our 12-month window
                if (months.includes(monthYear)) {
                    issuesByUnit[issue.unit].data[monthYear]++;
                }
            }
        });

        // Prepare datasets for the chart
        const datasets = units.map((unit, index) => {
            return {
                label: unit,
                data: months.map(month => issuesByUnit[unit].data[month]),
                borderColor: issuesByUnit[unit].color,
                backgroundColor: issuesByUnit[unit].color + '20', // Adding transparency
                borderWidth: 2,
                pointRadius: 3,
                pointHoverRadius: 5,
                tension: 0.1,
                fill: false,
                hidden: index > 4 // Show only first 5 units by default to avoid overcrowding
            };
        });

        // Create chart
        unitComparisonChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Issue Comparison by Unit',
                        font: {
                            size: 16,
                            weight: 'bold'
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                return tooltipItems[0].label;
                            },
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                label += context.parsed.y;
                                return label;
                            }
                        }
                    },
                    legend: {
                        display: false // Hide default legend since we're using custom toggle buttons
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Month'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Issues'
                        },
                        suggestedMin: 0,
                        ticks: {
                            stepSize: 1
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });

        // Create toggle buttons for each unit
        createUnitToggleButtons(units, issuesByUnit);
    }

    // Create toggle buttons for the units
    function createUnitToggleButtons(units, issuesByUnit) {
        const container = document.getElementById('unit-toggle-buttons');
        container.innerHTML = ''; // Clear existing buttons

        units.forEach((unit, index) => {
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'inline-block';
            buttonContainer.style.margin = '5px';

            const button = document.createElement('button');
            button.innerText = unit;
            button.style.background = issuesByUnit[unit].color;
            button.style.color = 'white';
            button.style.border = 'none';
            button.style.padding = '8px 15px';
            button.style.borderRadius = '20px';
            button.style.cursor = 'pointer';
            button.style.opacity = index <= 4 ? '1' : '0.5'; // Match initial visibility
            button.style.transition = 'opacity 0.3s';
            button.dataset.active = index <= 4 ? 'true' : 'false';
            button.dataset.unit = unit;

            button.addEventListener('click', function() {
                const isActive = this.dataset.active === 'true';

                // Toggle active state
                this.dataset.active = isActive ? 'false' : 'true';
                this.style.opacity = isActive ? '0.5' : '1';

                // Find the dataset in the chart
                const datasetIndex = unitComparisonChart.data.datasets.findIndex(d => d.label === this.dataset.unit);

                if (datasetIndex !== -1) {
                    // Toggle visibility
                    unitComparisonChart.data.datasets[datasetIndex].hidden = isActive;
                    unitComparisonChart.update();
                }
            });

            buttonContainer.appendChild(button);
            container.appendChild(buttonContainer);
        });

        // Add event listeners for Select All and Clear All buttons
        document.getElementById('select-all-units').addEventListener('click', function() {
            const buttons = container.querySelectorAll('button');
            buttons.forEach(button => {
                button.dataset.active = 'true';
                button.style.opacity = '1';

                const datasetIndex = unitComparisonChart.data.datasets.findIndex(d => d.label === button.dataset.unit);
                if (datasetIndex !== -1) {
                    unitComparisonChart.data.datasets[datasetIndex].hidden = false;
                }
            });
            unitComparisonChart.update();
        });

        document.getElementById('clear-units').addEventListener('click', function() {
            const buttons = container.querySelectorAll('button');
            buttons.forEach(button => {
                button.dataset.active = 'false';
                button.style.opacity = '0.5';

                const datasetIndex = unitComparisonChart.data.datasets.findIndex(d => d.label === button.dataset.unit);
                if (datasetIndex !== -1) {
                    unitComparisonChart.data.datasets[datasetIndex].hidden = true;
                }
            });
            unitComparisonChart.update();
        });
    }
</script>


<script>
    // Issue items Tab
    // Global variables for issue items charts
    let issueItemsPieChart = null;
    let issueItemsBarChart = null;

    // Function to create the issue items charts
    function createIssueItemsCharts(data) {
        // Extract issue items data
        const issueItemsData = {};

        // Count occurrences of each issue item
        data.forEach(issue => {
            if (issue.issue_item_name) {
                if (!issueItemsData[issue.issue_item_name]) {
                    issueItemsData[issue.issue_item_name] = 0;
                }
                issueItemsData[issue.issue_item_name]++;
            }
        });

        // Sort issue items by count (descending)
        const sortedIssueItems = Object.entries(issueItemsData)
            .sort((a, b) => b[1] - a[1]);

        // Get item names and counts
        const itemNames = sortedIssueItems.map(item => item[0]);
        const itemCounts = sortedIssueItems.map(item => item[1]);

        // Generate colors for pie chart
        const colors = generatePieColors(itemNames.length);

        // Create pie chart with outer labels
        createIssueItemsPieChart(itemNames, itemCounts, colors);

        // Create horizontal bar chart
        createIssueItemsBarChart(itemNames, itemCounts, colors);
    }

    // Function to create the issue items pie chart with outer labels
    function createIssueItemsPieChart(labels, data, colors) {
        const ctx = document.getElementById('issue-items-pie-chart').getContext('2d');

        // Destroy previous chart if exists
        if (issueItemsPieChart) issueItemsPieChart.destroy();

        // Instead of using complex custom plugins, use a doughnut chart with simple labels
        issueItemsPieChart = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: colors,
                    borderWidth: 1,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: 20
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'right',
                        labels: {
                            generateLabels: function(chart) {
                                // Custom logic to generate labels with counts
                                const data = chart.data;
                                if (data.labels.length && data.datasets.length) {
                                    return data.labels.map((label, i) => {
                                        const meta = chart.getDatasetMeta(0);
                                        const ds = data.datasets[0];
                                        const arc = meta.data[i];
                                        const value = ds.data[i];

                                        return {
                                            text: `${label} (${value})`,
                                            fillStyle: ds.backgroundColor[i],
                                            strokeStyle: ds.borderColor[i],
                                            lineWidth: ds.borderWidth,
                                            hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                                            index: i
                                        };
                                    });
                                }
                                return [];
                            },
                            boxWidth: 15,
                            padding: 10
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = Math.round((value / total) * 100);
                                return `${context.label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Function to create the issue items horizontal bar chart
    function createIssueItemsBarChart(labels, data, colors) {
        const ctx = document.getElementById('issue-items-bar-chart').getContext('2d');

        // Destroy previous chart if exists
        if (issueItemsBarChart) issueItemsBarChart.destroy();

        // Limit to top 15 items for readability
        // const topLabels = labels.slice(0, 15);
        // const topData = data.slice(0, 15);
        // const topColors = colors.slice(0, 15);

        // Create horizontal bar chart
        issueItemsBarChart = new Chart(ctx, {
            type: 'bar',
            data: {
                // labels: topLabels,
                labels: labels,
                datasets: [{
                    label: 'Quantity',
                    // data: topData,
                    data: data,
                    // backgroundColor: topColors,
                    backgroundColor: colors,
                    // borderColor: topColors.map(color => color.replace('0.7', '1')),
                    borderColor: colors.map(color => color.replace('0.7', '1')),
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y', // Horizontal bar chart
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false // Hide legend
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Quantity: ${context.raw}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Quantity'
                        },
                        ticks: {
                            stepSize: 1,
                            precision: 0 // Round to whole numbers
                        }
                    },
                    y: {
                        title: {
                            display: false
                        }
                    }
                }
            }
        });
    }

    // Generate colors for pie chart segments
    function generatePieColors(count) {
        // Define a color palette
        const baseColors = [
            'rgba(129, 130, 200, 0.7)', // Purple (#8182c8)
            'rgba(243, 199, 113, 0.7)', // Gold (#f3c771)
            'rgba(129, 166, 227, 0.7)', // Light Blue (#81a6e3)
            'rgba(146, 208, 181, 0.7)', // Mint Green (#92d0b5)
            'rgba(182, 224, 127, 0.7)', // Light Green (#b6e07f)
            'rgba(232, 234, 119, 0.7)', // Yellow (#e8ea77)
            'rgba(239, 147, 103, 0.7)', // Orange (#ef9367)
            'rgba(243, 122, 119, 0.7)', // Coral (#f37a77)
            'rgba(108, 110, 163, 0.7)', // Deep Purple (#6c6ea3)
            'rgba(44, 71, 97, 0.7)'     // Navy (#2c4761)
        ];

        // If we need more colors than in our base palette, we'll generate them
        if (count <= baseColors.length) {
            return baseColors.slice(0, count);
        } else {
            const colors = [...baseColors];

            // Generate additional colors by varying hue
            for (let i = baseColors.length; i < count; i++) {
                const hue = (i * 37) % 360; // Use prime number to get good distribution
                colors.push(`hsla(${hue}, 70%, 60%, 0.7)`);
            }

            return colors;
        }
    }
</script>
<script>
    // Issue Solutions Tab
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize the issue solutions tab functionality
        initIssueSolutionsTab();
    });

    function initIssueSolutionsTab() {
        // Event listeners for view toggle buttons
        document.getElementById('card-view-btn').addEventListener('click', function() {
            toggleView('card');
        });

        document.getElementById('list-view-btn').addEventListener('click', function() {
            toggleView('list');
        });

        // Event listeners for all filters
        document.getElementById('solution-date-filter').addEventListener('change', function() {
            updateSolutionsDisplay();
        });

        document.getElementById('solution-unit-filter').addEventListener('change', function() {
            updateSolutionsDisplay();
        });

        document.getElementById('solution-reporter-filter').addEventListener('change', function() {
            updateSolutionsDisplay();
        });
    }

    // Function to toggle between card and list views
    function toggleView(viewType) {
        const container = document.getElementById('solution-container');
        const cardBtn = document.getElementById('card-view-btn');
        const listBtn = document.getElementById('list-view-btn');

        if (viewType === 'card') {
            container.className = 'card-view';
            cardBtn.className = 'view-toggle-btn active';
            cardBtn.style.background = '#ee4d2d';
            cardBtn.style.color = 'white';
            listBtn.className = 'view-toggle-btn';
            listBtn.style.background = '#f8f9fa';
            listBtn.style.color = '#333';
        } else {
            container.className = 'list-view';
            listBtn.className = 'view-toggle-btn active';
            listBtn.style.background = '#ee4d2d';
            listBtn.style.color = 'white';
            cardBtn.className = 'view-toggle-btn';
            cardBtn.style.background = '#f8f9fa';
            cardBtn.style.color = '#333';
        }

        updateSolutionsDisplay();
    }

    // Function to populate the filter dropdowns
    function populateFilterDropdowns(issues) {
        // Get unique units
        const units = [...new Set(issues.filter(issue => issue.unit).map(issue => issue.unit))];
        const unitFilter = document.getElementById('solution-unit-filter');

        // Clear current options except the first one
        while (unitFilter.options.length > 1) {
            unitFilter.remove(1);
        }

        // Add units to dropdown
        units.sort().forEach(unit => {
            const option = document.createElement('option');
            option.value = unit;
            option.textContent = unit;
            unitFilter.appendChild(option);
        });

        // Get unique reporters
        const reporters = [...new Set(issues.filter(issue => issue.reported_by_name).map(issue => issue.reported_by_name))];
        const reporterFilter = document.getElementById('solution-reporter-filter');

        // Clear current options except the first one
        while (reporterFilter.options.length > 1) {
            reporterFilter.remove(1);
        }

        // Add reporters to dropdown
        reporters.sort().forEach(reporter => {
            const option = document.createElement('option');
            option.value = reporter;
            option.textContent = reporter;
            reporterFilter.appendChild(option);
        });
    }

    // Build the category and issue item tree from the issues data
    function buildCategoryTree(issues) {
        const categoryTree = document.getElementById('category-tree');
        categoryTree.innerHTML = '';

        // Group issues by category
        const categorizedIssues = {};

        issues.forEach(issue => {
            if (issue.category_name && issue.issue_item_name) {
                if (!categorizedIssues[issue.category_name]) {
                    categorizedIssues[issue.category_name] = {};
                }

                if (!categorizedIssues[issue.category_name][issue.issue_item_name]) {
                    categorizedIssues[issue.category_name][issue.issue_item_name] = [];
                }

                categorizedIssues[issue.category_name][issue.issue_item_name].push(issue);
            }
        });

        // Build tree structure
        for (const category in categorizedIssues) {
            const categoryElement = document.createElement('div');
            categoryElement.className = 'category-item';
            categoryElement.style.marginBottom = '15px';

            const categoryHeader = document.createElement('div');
            categoryHeader.className = 'category-header';
            categoryHeader.style.fontSize = '1.1rem';
            categoryHeader.style.fontWeight = 'bold';
            categoryHeader.style.color = '#333';
            categoryHeader.style.padding = '8px 10px';
            categoryHeader.style.backgroundColor = '#f8f9fa';
            categoryHeader.style.borderRadius = '4px';
            categoryHeader.style.cursor = 'pointer';
            categoryHeader.style.display = 'flex';
            categoryHeader.style.justifyContent = 'space-between';
            categoryHeader.style.alignItems = 'center';

            const categoryLabel = document.createElement('span');
            categoryLabel.textContent = category;

            const categoryIcon = document.createElement('span');
            categoryIcon.textContent = '';
            categoryIcon.style.fontSize = '12px';
            categoryIcon.style.transition = 'transform 0.3s';

            categoryHeader.appendChild(categoryLabel);
            categoryHeader.appendChild(categoryIcon);
            categoryElement.appendChild(categoryHeader);

            const issueList = document.createElement('div');
            issueList.className = 'issue-list';
            issueList.style.marginLeft = '15px';
            issueList.style.marginTop = '8px';
            issueList.style.display = 'none';

            for (const issueItem in categorizedIssues[category]) {
                const issueItemElement = document.createElement('div');
                issueItemElement.className = 'issue-item';
                issueItemElement.style.padding = '6px 10px';
                issueItemElement.style.marginBottom = '5px';
                issueItemElement.style.color = '#495057';
                issueItemElement.style.cursor = 'pointer';
                issueItemElement.style.borderLeft = '3px solid #dee2e6';
                issueItemElement.textContent = issueItem;

                issueItemElement.addEventListener('mouseover', function() {
                    this.style.backgroundColor = '#f8f9fa';
                });

                issueItemElement.addEventListener('mouseout', function() {
                    this.style.backgroundColor = 'transparent';
                });

                issueItemElement.addEventListener('click', function() {
                    // Remove active class from all issue items
                    document.querySelectorAll('.issue-item.active').forEach(el => {
                        el.classList.remove('active');
                        el.style.backgroundColor = 'transparent';
                        el.style.borderLeftColor = '#dee2e6';
                        el.style.fontWeight = 'normal';
                    });

                    // Add active class to clicked issue
                    this.classList.add('active');
                    this.style.backgroundColor = '#f8f9fa';
                    this.style.borderLeftColor = '#ee4d2d';
                    this.style.fontWeight = 'bold';

                    // Display solutions for this issue item
                    displaySolutions(categorizedIssues[category][issueItem]);
                });

                issueList.appendChild(issueItemElement);
            }

            categoryElement.appendChild(issueList);

            // Toggle expand/collapse on category click
            categoryHeader.addEventListener('click', function() {
                if (issueList.style.display === 'block') {
                    issueList.style.display = 'none';
                    categoryIcon.textContent = '';
                    categoryIcon.style.transform = 'rotate(0deg)';
                } else {
                    issueList.style.display = 'block';
                    categoryIcon.textContent = '';
                    categoryIcon.style.transform = 'rotate(0deg)';
                }
            });

            categoryTree.appendChild(categoryElement);
        }

        // Populate filter dropdowns with data from all issues
        populateFilterDropdowns(issues);
    }

    // Display solutions for selected issue item
    function displaySolutions(issues) {
        const solutionsContainer = document.getElementById('solutions-list');
        const noSolutionMessage = document.getElementById('no-solution-selected');

        // Show solutions container
        solutionsContainer.style.display = 'block';
        noSolutionMessage.style.display = 'none';

        // Apply all filters
        let filteredIssues = applyAllFilters(issues);

        // Check if we have any solutions after filtering
        if (filteredIssues.length === 0) {
            solutionsContainer.innerHTML = '<div style="text-align: center; padding: 30px; color: #6c757d;"><p>No solutions found with the current filters</p></div>';
            return;
        }

        // Generate the content based on the current view mode
        if (document.getElementById('solution-container').className === 'card-view') {
            renderCardView(solutionsContainer, filteredIssues);
        } else {
            renderListView(solutionsContainer, filteredIssues);
        }
    }

    // Function to apply all filters (date, unit, and reporter)
    function applyAllFilters(issues) {
        // Get filter values
        const dateFilter = document.getElementById('solution-date-filter').value;
        const unitFilter = document.getElementById('solution-unit-filter').value;
        const reporterFilter = document.getElementById('solution-reporter-filter').value;

        // Apply filters
        return issues.filter(issue => {
            // Apply date filter
            if (!passesDateFilter(issue, dateFilter)) {
                return false;
            }

            // Apply unit filter
            if (unitFilter !== 'all' && issue.unit !== unitFilter) {
                return false;
            }

            // Apply reporter filter
            if (reporterFilter !== 'all' && issue.reported_by_name !== reporterFilter) {
                return false;
            }

            // If it passes all filters, include it
            return true;
        });
    }

    // Function to check if an issue passes the date filter
    function passesDateFilter(issue, dateFilter) {
        if (dateFilter === 'all') return true;

        const issueDate = new Date(issue.date_added);
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

        switch (dateFilter) {
            case 'today':
                return issueDate >= today;
            case 'yesterday':
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                return issueDate >= yesterday && issueDate < today;
            case 'this-week':
                const thisWeekStart = new Date(today);
                thisWeekStart.setDate(today.getDate() - today.getDay());
                return issueDate >= thisWeekStart;
            case 'last-week':
                const lastWeekStart = new Date(today);
                lastWeekStart.setDate(today.getDate() - today.getDay() - 7);
                const lastWeekEnd = new Date(today);
                lastWeekEnd.setDate(today.getDate() - today.getDay() - 1);
                return issueDate >= lastWeekStart && issueDate <= lastWeekEnd;
            case 'this-month':
                const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                return issueDate >= thisMonthStart;
            case 'last-month':
                const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
                return issueDate >= lastMonthStart && issueDate <= lastMonthEnd;
            case 'this-year':
                const thisYearStart = new Date(now.getFullYear(), 0, 1);
                return issueDate >= thisYearStart;
            case 'last-year':
                const lastYearStart = new Date(now.getFullYear() - 1, 0, 1);
                const lastYearEnd = new Date(now.getFullYear() - 1, 11, 31);
                return issueDate >= lastYearStart && issueDate <= lastYearEnd;
            default:
                return true;
        }
    }

    // Render solutions in card view
    function renderCardView(container, issues) {
        container.innerHTML = '';

        const cardGrid = document.createElement('div');
        cardGrid.style.display = 'grid';
        cardGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(350px, 1fr))';
        cardGrid.style.gap = '20px';

        issues.forEach(issue => {
            const card = document.createElement('div');
            card.className = 'solution-card';
            card.style.backgroundColor = 'white';
            card.style.borderRadius = '8px';
            card.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
            card.style.padding = '20px';

            let priorityColor = '#6c757d'; // Default gray
            if (issue.priority_name === 'High') {
                priorityColor = '#dc3545'; // Red
            } else if (issue.priority_name === 'Medium') {
                priorityColor = '#ffc107'; // Yellow
            } else if (issue.priority_name === 'Low') {
                priorityColor = '#28a745'; // Green
            }

            card.innerHTML = `
                <div style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <h5 style="margin: 0; font-size: 1.1rem; color: #333;">${issue.issue_item_name || 'No Item'}</h5>
                        <span style="color: ${priorityColor}; font-weight: bold;">${issue.priority_name || 'No Priority'}</span>
                    </div>
                    <div style="color: #6c757d; font-size: 0.9rem;">
                        <div>Unit: ${issue.unit || 'N/A'}</div>
                        <div>Status: ${issue.status_name || 'N/A'}</div>
                        <div>Type: ${issue.type_name || 'N/A'}</div>
                        <div>Cost: ${issue.cost ? 'RM' + issue.cost : 'N/A'}</div>
                        <div>Reported by: ${issue.reported_by_name || 'N/A'}</div>
                        <div>Date: ${formatDate(issue.date_added)}</div>
                        <div>Assigned to: ${issue.assigned_to || 'N/A'}</div>
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <h6 style="margin: 0 0 8px 0; font-size: 0.95rem; color: #495057;">Description:</h6>
                    <p style="margin: 0; color: #212529;">${issue.description || 'No description provided'}</p>
                </div>
                <div>
                    <h6 style="margin: 0 0 8px 0; font-size: 0.95rem; color: #495057;">Solution:</h6>
                    <p style="margin: 0; color: #212529;">${issue.solution || 'No solution provided'}</p>
                </div>
            `;

            cardGrid.appendChild(card);
        });

        container.appendChild(cardGrid);
    }

    // Render solutions in list view
    function renderListView(container, issues) {
        container.innerHTML = '';

        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'collapse';

        // Create table header
        const thead = document.createElement('thead');
        thead.innerHTML = `
            <tr>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Date</th>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Unit</th>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Issue</th>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Description</th>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Solution</th>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Status</th>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Type</th>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Cost</th>
                <th style="padding: 12px 15px; text-align: left; background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">Priority</th>
            </tr>
        `;
        table.appendChild(thead);

        // Create table body
        const tbody = document.createElement('tbody');

        issues.forEach(issue => {
            const tr = document.createElement('tr');
            tr.style.borderBottom = '1px solid #dee2e6';

            let priorityColor = '#6c757d'; // Default gray
            if (issue.priority_name === 'High') {
                priorityColor = '#dc3545'; // Red
            } else if (issue.priority_name === 'Medium') {
                priorityColor = '#ffc107'; // Yellow
            } else if (issue.priority_name === 'Low') {
                priorityColor = '#28a745'; // Green
            }

            tr.innerHTML = `
                <td style="padding: 12px 15px; text-align: left;">${formatDate(issue.date_added)}</td>
                <td style="padding: 12px 15px; text-align: left;">${issue.unit || 'N/A'}</td>
                <td style="padding: 12px 15px; text-align: left;">${issue.issue_item_name || 'No Item'}</td>
                <td style="padding: 12px 15px; text-align: left;">${issue.description || 'No description'}</td>
                <td style="padding: 12px 15px; text-align: left;">${issue.solution || 'No solution'}</td>
                <td style="padding: 12px 15px; text-align: left;">${issue.status_name || 'N/A'}</td>
                <td style="padding: 12px 15px; text-align: left;">${issue.type_name || 'N/A'}</td>
                <td style="padding: 12px 15px; text-align: left;">${issue.cost ? 'RM' + issue.cost : 'N/A'}</td>
                <td style="padding: 12px 15px; text-align: left; color: ${priorityColor}; font-weight: bold;">${issue.priority_name || 'N/A'}</td>
            `;

            tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        container.appendChild(table);
    }

    // Format date for display
    function formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    // Update the solutions display based on current filters and selected issue
    function updateSolutionsDisplay() {
        const activeIssueItem = document.querySelector('.issue-item.active');
        if (activeIssueItem) {
            activeIssueItem.click();
        }
    }

    // Update dashboard function to include building the category tree
    const originalUpdateDashboard = updateDashboard;
    updateDashboard = function(data) {
        // Call the original function first
        originalUpdateDashboard(data);

        // Build the category tree for the issue solutions tab
        buildCategoryTree(data);
    };
</script>
{% endblock %}